<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F21%2FHTTP%E4%B8%8EHTTPS%2F</url>
    <content type="text"><![CDATA[HTTP与HTTPS HTTP 过程 版本 版本 产生时间 内容 发展现状 HTTP/0.9 1991年 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求 没有作为正式的标准 HTTP/1.0 1996年 传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令 正式作为标准 HTTP/1.1 1997年 持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码 2015年前使用最广泛 HTTP/2 2015年 多路复用、服务器推送、头信息压缩、二进制协议等 逐渐覆盖市场 HTTP vs HTTPS 无连接 限制每次连接只处理一个请求。服务器处理完客户的请求并收到客户的应答后断开连接。采用这种方式可以节省时间 HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。 比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。 无状态 协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。 比如访问一个网站需要反复进行登录操作 用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。而HTTP为无状态协议，一旦数据交换完毕，则会关闭会话，下一次连接请求时，就不能获取上次的会话，即不能保存购物车中的信息 基于请求和响应：基本的特性，由客户端发起请求，服务端响应 简单快速、灵活 通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性 HTTP/1.1 vs HTTP/2.0采用多路复用的技术，通过单一的TCP请求发送多个请求内容。而不像HTTP/1.1，因为一个TCP连接请求只能请求一个信息，所以需要建立多个TCP请求，网站请求速度太慢 针对HTTP无状态，无连接而导致需要多次请求服务器 HTTP/1.1持久连接（HTTP keep-alive），只要任意一端没有明确提出断开连接，则保持TCP连接状态。在请求首部字段中的Connection：keep-alive中表明使用持久连接。Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。但http为无状态协议，每一个请求都是独立的，keep-alive不能改变无状态的问题 通过Cookie/Session技术解决http无状态问题 Cookie：缺点为每次都要向Server发送浏览器中保存的所有cookie与Server中进行匹配，这消耗了Server的资源，安全性不高 Session：存储在服务器端，安全性较高。通过cookie中的session id获取保存在服务器端的session信息。因为session存放在服务器的内存中，过多的信息会导致服务器负担加重，所以会把重要的信息存放在session中，不重要的信息存放在cookie中 应用http/2.0多路复用，一次请求可以得到多个所需要的文件 HTTPS 认证过程 Client向Server发送请求https://www.baidu.com，然后连接到server的443 port Server端必须有一套数字证书。自己颁发的证书需要Client允许才能继续访问，向组织申请的证书则不会弹出提示页面。Web将https://www.baidu.com的网站证书（其实就是公钥，但是包含了很多信息证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容）发送给Client，Client收到后会与浏览器中内置的证书对比，如果不安全则会提示有风险 Client解析证书 这部分工作是由Client的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（秘钥）。然后用证书对该随机值进行加密。并发送给Server Server使用私钥解密得到秘钥，以后Server与Client通信使用此秘钥怎么保证Server给Client下发的是真正的公钥而不是中间人伪造的？中间人攻击 解决方案：中间人可以伪装证书中的公钥，所以就不让他伪装。使用CA证书机构中定制的私钥对证书进行加密。中间人没有此私钥。客户端就会拒收中间人发送来的公钥1234中间人攻击？ 中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取 通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或 者公共路由上。 过程 数字证书包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要，然后根据证书上描述的计算证书的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。 那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名 SSL与TLS的区别 SSL：Secure Socket Layer，安全套接字层。位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。 TLS：Transport Layer Security，传输层安全协议。用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。 总结安全性考虑 HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用 SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行 成本考虑 费钱：SSL证书需要购买申请，功能越强大的证书费用越高 IPv4资源有限：SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用） 耗电：根据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。 HTTPS连接缓存不如HTTP高效，流量成本高。 HTTPS连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。 HTTPS协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，例如12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。 中间人攻击中间人攻击（MITM攻击）：黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。 Cookie cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。 cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。 Session session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。 器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。 Token过程 用户登录校验，校验成功后就返回Token给客户端。 客户端收到数据后保存在客户端 客户端每次访问API是携带Token到服务器端。 服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码 特性 无状态，可扩展 安全性 可扩展性 多平台跨域 详细介绍https://www.cnblogs.com/moyand/p/9047978.htm]]></content>
  </entry>
  <entry>
    <title><![CDATA[CDN]]></title>
    <url>%2F2019%2F02%2F03%2FCDN%2F</url>
    <content type="text"><![CDATA[原理图当用户请求一个文件时，cdn工作过程如下 DNS迭代查询local DNS 当地local DNS递归查询服务器的GSLB（全局负载均衡） GSLB根据local DNS返回最佳CDN接入节点IP给User 用户得到最佳CDN接入点IP 如果该节点没有用户想要获取的内容，则通过内部路由访问上一个节点，直到找到文件或到达源站为止 CDN接入点缓存该数据，下次请求文件时可以直接返回 参考资料：腾讯云CDN，漫画讲解CDN，CDN技术详解]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>CDN</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kubeadm快速部署kubernetes]]></title>
    <url>%2F2019%2F02%2F01%2Fkubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes%2F</url>
    <content type="text"><![CDATA[kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。 这个工具能通过两条指令完成一个kubernetes集群的部署： 12345# 创建一个 Master 节点$ kubeadm init# 将一个 Node 节点加入到当前集群中$ kubeadm join &lt;Master节点的IP和端口 &gt; 安装要求在开始之前，部署Kubernetes集群机器需要满足以下几个条件： 一台或多台机器，操作系统 CentOS7.x-86_x64 硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多 集群中所有机器之间网络互通 可以访问外网，需要拉取镜像 禁止swap分区 学习目标 在所有节点上安装Docker和kubeadm 部署Kubernetes Master 部署容器网络插件 部署 Kubernetes Node，将节点加入Kubernetes集群中 部署Dashboard Web页面，可视化查看Kubernetes资源 准备环境Kubernetes 架构图 123456789101112131415161718192021222324关闭防火墙：$ systemctl stop firewalld$ systemctl disable firewalld关闭selinux：$ sed -i &apos;s/enforcing/disabled/&apos; /etc/selinux/config $ setenforce 0关闭swap：$ swapoff -a $ 临时$ vim /etc/fstab $ 永久添加主机名与IP对应关系（记得设置主机名）：$ cat /etc/hosts192.168.137.5 k8s-master192.168.137.100 k8s-node1192.168.137.101 k8s-node2将桥接的IPv4流量传递到iptables的链：$ cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF$ sysctl --system 所有节点安装Docker/kubeadm/kubeletKubernetes默认CRI（容器运行时）为Docker，因此先安装Docker。 安装Docker12345$ wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo$ yum -y install docker-ce-18.06.1.ce-3.el7$ systemctl enable docker &amp;&amp; systemctl start docker$ docker --versionDocker version 18.06.1-ce, build e68fc7a 添加阿里云YUM软件源123456789$ cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF 安装kubeadm，kubelet和kubectl由于版本更新频繁，这里指定版本号部署： 12345$ yum install -y kubelet-1.13.3 kubeadm-1.13.3 kubectl-1.13.3$ systemctl enable kubelet#kubeadm：初始化Cluster#kubelet：运行在Cluster上的所有节点，启动Pod和容器#kubectl：Kubernetes命令行工具 ##部署Kubernetes Master 123456789101112131415161718$ kubeadm init \ --apiserver-advertise-address=192.168.137.5 \ --image-repository registry.aliyuncs.com/google_containers \ --kubernetes-version v1.13.3 \ --service-cidr=10.1.0.0/16\ --pod-network-cidr=10.244.0.0/16 #--apiserver-advertise-address=192.168.137.5：指定Master的哪个interface与Cluster的其他节点通信，如果不指定，则自动选择有默认GW的interface #--pod-network-cidr=10.244.137.0/16：Pod网络范围，为了使用flannel方案，则必须设置此网段的CIDR 1、kubeadm执行初始化检查 2、生成token和证书 3、生成KubeConfig文件，Kubelet需要用这个文件与Master通信 4、安装Master组件，会从Google的Regisry下载组件的Dokcer镜像 5、安装附加组件kube-proxy和kube-dns 6、Kubernets初始化成功 ！！ kubectl get pods -n kube-system检测镜像是否下载成功 ！！ kubectl delete pods kube-flannel-ds-amd64-s5t56 -n kube-system 由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址。 使用kubectl工具：推荐使用普通用户执行，root用户有些问题 1234mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config$ kubectl get nodes 安装Pod网络插件（CNI）1$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml 确保能够访问到quay.io这个registery。 加入Kubernetes Node在node上执行！！！！！！！！！！！使用kubectl get node查看向集群添加新节点，执行在kubeadm init输出（master上）的kubeadm join命令： 12$ kubeadm join 192.168.137.5:6443 --token hm2vby.27zp6mugvhaio2yu --discovery-token-ca-cert-hash sha256:4ae8da8f9c9319cb7980ea8f91b93baca34d77be67bcb35c89ef7faffae2bcbc#使用--node-name [string] 指定加入kubernetes集群的主机名 测试kubernetes集群在Kubernetes集群中创建一个pod，验证是否正常运行： 123$ kubectl create deployment nginx --image=nginx$ kubectl expose deployment nginx --port=80 --type=NodePort$ kubectl get pod,svc 访问地址：http://NodeIP:Port 部署 Dashboard1$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml 默认镜像国内无法访问，修改镜像地址为： lizhenliang/kubernetes-dashboard-amd64:v1.10.1 默认Dashboard只能集群内部访问，修改Service为NodePort类型，暴露到外部： 123456789101112131415kind: ServiceapiVersion: v1metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-systemspec: type: NodePort ports: - port: 443 targetPort: 8443 nodePort: 30001 selector: k8s-app: kubernetes-dashboard 1$ kubectl apply -f kubernetes-dashboard.yaml 访问地址：http://NodeIP:30001 创建service account并绑定默认cluster-admin管理员集群角色： 123$ kubectl create serviceaccount dashboard-admin -n kube-system$ kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin$ kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk &apos;/dashboard-admin/&#123;print $1&#125;&apos;) 使用输出的token登录Dashboard。]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
</search>
